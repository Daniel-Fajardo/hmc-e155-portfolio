[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "E155 Course Website"
  },
  {
    "objectID": "posts/lab5-reflection.html",
    "href": "posts/lab5-reflection.html",
    "title": "Lab5 Reflection",
    "section": "",
    "text": "This lab was a fun one. Having access to SEGGER’s CMSIS files made referencing the datasheet so much easier. The ability to trust that the register addresses were correct without constantly checking the reference manual allowed for much quicker debugging. I also found that I was able to grasp the concept of interrupts fairly quickly. I also found that after struggling through lab 4, my process for debugging greatly improved. Overall this lab gave me the needed confidence boost and inspiration to continue working on the final two labs."
  },
  {
    "objectID": "posts/lab3-reflection.html",
    "href": "posts/lab3-reflection.html",
    "title": "Lab3 Reflection",
    "section": "",
    "text": "This lab was very intellectually challenging for me. The process of understanding how the fsm should function took some time and then figuring out how to approach it was more difficult. Once I had a solid grasp, I was able to get the design to work well in simulation in little time. The speed of development was thanks to implementing testbenches in QuestaSim for the first time in this class, which allowed for quick debugging.\nThe frustrating part of this lab came in trying to transfer a design that was working perfectly in simulation into a design that works in hardware. My first issue came in synthesizing the design in Lattice Radiant. I had inferred a number of latches by not defining each output in each state in my fsm. By splitting my fsm into multiple fsms in the same module (one for state, nextstate, and others for outputs), I solved this issue. The next issue came from the button push not registering correctly. In simulation, a button input would hold the column high, but this was not happening in hardware. I realized that the timing of the column output was not correct and that I was also getting contention when buttons in multiple rows were pushed at the same time. These issues remained for a while but once I discovered them, the fix was quick.\nAfter finally getting the design to work in hardware, I felt mostly relief. I felt relief because I had felt like I had total conceptual understanding of the problem, yet the system was not acting how I expected it to. This lab gave me practice in perseverance and patience. After about two weeks of working on this lab, I took a few days off, and on the first day back working on it I was able to figure it out."
  },
  {
    "objectID": "posts/lab1-reflection.html",
    "href": "posts/lab1-reflection.html",
    "title": "Lab1 Reflection",
    "section": "",
    "text": "The most difficult part of this lab by far was debugging each software application so that it would correctly upload to the fpga and mcu. The challenges lied in assuring that I had the correct software installed with the correct licenses and the correct hardware drivers. On my personal device, I struggled to get Lattice Radiant to synthesize the FPGA and getting SEGGER to drive the MCU remains unresolved. Because of these struggles, I had to complete the lab using the computers in HMC’s digital lab.\nOnce the software and hardware appeared to be working enough to get started, I found the verilog module design to be fairly straight forward. Calculating the combinational logic for the 7-segment display was the most labor intensive part of the process for me and writing the HDL was quite simple. There was minimal debugging of the code, as the majority of the debugging came from understanding how Lattice Radiant works.\nThis lab also challenged my orginizational skills. This was the first project I have organized using github and learning the nuances took some time."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab4: Digital Audio",
    "section": "",
    "text": "Introduction\nThis was the first lab built entirely on the STM32 microcontroller. The system is capable of playing music on an 8-ohm speaker after amplification by an LM386 audio amplifier. The design contains a library written from scratch that configures the clock for PWM output. The MCU then reads a list of notes specifying the pitch (in Hz) and durations in (ms) for each note and plays each note for its tupled pitch and duration.\n\n\nDesign and Testing Methodology\nThis lab included four files for configuring peripherals. The first being FLASH to prefetch the MCU RAM so that the following registers can be updated. The second peripheral is RCC, which is used for configuring the clock as phase locked loop (PLL) with the source clock being MSI at 4 MHz and the output frequency being 80 MHz. The next peripheral is TIM to configure the timers used in the system. This peripheral gets called twice to output a given frequency for the note and a given duration of that note. The final peripheral is GPIO, which is used to produce a PWM output to a pin in order to drive the speaker. The FLASH and GPIO header and configuration files were given to me, the RCC header file was given but the configuration file was written with a tutorial, and the TIM header and configuration files were written from scratch. Peripheral structs and registers were all configured with reference to the STM32L432KC reference manual.\nThe design starts by configuring flash then configuring the clock in RCC. Next the clock gets turned on to GPIOA with alternate function 14, allowing for pwm. Then timers 15 and 16 are enabled in RCC and configured in TIM. After this initialization, the design steps into a while (1) loop that cycles through each note in the tupled list of pitch and duration. Inside this loop, the frequency is set on timer 16 and duration is set on timer 15.\n\n\n\nFigure 1: Frequency Calculations\n\n\nThe setfreq function first checks if desired frequency is zero or not. If it is, that denotes a pause and no pwm is output (counter is disabled). If it is not, the auto-reload register (ARR) register is set to produce the period length in bits (which are updated at the frequency of 80MHz/prescalar). Next the duty cycle is set to 50% by having the capture/compare register (CCR1) be set to half of ARR. An update event is called in event generation register (EGR) and the counter is enabled again. Now the GPIO will output a square wave with a period determined by the length of ARR.\n\n\n\nFigure 2: Duration Calculation\n\n\nThe setdur function is more simple (Figure 2). ARR is set by defining the total length of the desired duration with the above calculation, EGR is called and then the status register (SR) is reset to wait for overflow in the counter and counter are reset to zero. Finally, a while loop waits until SR detects overflow, which should take the desired duration to occur.\n\n\nTechnical Documentation\nThe source code for the project can be found in the associated Github Repository\n\n\nBlock Diagram\n\n\nSchematic\n\n\n\nFigure 3: Schematic of physical circuit\n\n\nThe circuit for this lab is very simple. Figure 3 illustrates the amplification of the output pin via the LM386 audio amplifier.\n\n\nResults and Discussion\n\nAs heard (quietly) in the video, the speaker can play Fur Elise at the correct pitch and tempo. The low volume output is a result of the chosen resistor of 15kOhms. With more time, I would experiment with lower resistor values to increase the voltage to the speaker so that the output is louder.\n\n\nConclusion\nThe solution successfully configures two TIM peripherals for pwm output on GPIO pins so that the system can play a given list of music notes (Fur Elise) at the correct tempo and pitch. I spent a total of 15 hours working on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "Introduction\nThis lab expanded on the previous lab by adding a second 7-segment digit display to the FPGA design. Instead of adding FPGA I/O pins to the design, the two displays were accessed via a multiplexer which oscillated at a rate just fast enough to give the illusion of them both being on at the same time. This lab also implemented transistors to turn on/off each display.\n\n\nDesign and Testing Methodology\nThe System Verilog in this lab was much more modular than in the previous lab. This lab resused the clock divider and 7-segment logic modules. This time the clock divider was adjusted to output clk at a frequency just above 90 Hz (this is the frequency at which humans are able to register) so that the two displays would appear on at the same time. At each positive edge of the clock, the chooseanode module would alternate which display would receive current to its anode. The current to each display was controlled via a transistor. The chooseanode module would also operate a mux (separate module) to select which of the two 4-bit inputs would be active and the chosen input would be sent to the 7-segment logic module, which would output the corresponding digit display. Finally, a module called leds would act as a full adder for the two inputs and would output the 5-bit sum on external leds.\n\n\nTechnical Documentation\nThe source code for the project can be found in the associated Github Repository\n\n\nBlock Diagram\n\n\n\nFigure 1: Block diagram of verilog\n\n\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The clock divider module utilizes the on-board high speed oscillator (HSOSC) from the iCE40 library and outputs the clock to be used for the choose anode module. The other two submodules are the segment logic and the leds module.\n\n\nSchematic\n\n\n\nFigure 2: Schematic of physical circuit\n\n\nThe schematic in Figure 2 shows the layout of the circuitry. The FPGA board is shown on the left with internal pull up resistors for the inputs and outputs. The inputs include the on-board 4-pin dip switch and an external 4-pin dip switch. The outputs include the leds, which are current limited by resistors, the segment display signals, which are connected in parallel, and finally the transistors, which have the 3.3V connected to the collector pins and a resistor connected to the base, while the emitter is hooked up to the display anodes.\n\n\nResults and Discussion\n\n\n\nFigure 3: Testbench simulation\n\n\nThe design was mostly successful. In simulation (Figure 3), the selected anode would correclty alternate on the rising edge of the clock, as would the output segment logic alternate between s1 and s2. The led adder logic also produced the expected outputs. The 7-segment logic continued to work, as it did in the previous lab. With all this, the top level module worked successfully, outputting the correct 7-segment and led logic at an alternating times.\nIn hardware, the design is fully successful only a fraction of the time. A large reason for this is poor solder joints which lead to incosistent pinouts. Another shortcoming is the current draw to some of the pins. This lab requires a large amount of current draw to handle all of its desired outputs. The 7-segment leds are not getting quite enough current and this is likely due to a large current pull elsewhere. I hope to adress each of these issues in the coming weeks, so that the design can perform more consistently, although when it does work it is reliably.\n\n\nConclusion\nThe design semiconsistently displays two digits using a mux to alternate between the displays at a frequency higher than the human eye can perceive. The design operates successfully at the will of the solder joint connections and with inconsistent current draw to each led. This lab took me roughly 20 hours to complete."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Daniel Fajardo is an engineering major at Harvey Mudd College. He is interested in pursuing a career in both electrical and mechanical engineering with a focus on areas that intersect both fields, such as mechatronics and systems engineering. His specific interests include embedded systems and microcontrollers, mechanical motion dynamics, and electrical design, which can be used to develop hardware and software solutions for automation and control systems. He also has a concentration in psychology and applies an interdisciplinary approach to solving engineering problems with environmental and human centered design considerations. He is also a member of the Claremont-Mudd-Scripps cross country team, receiving all-region awards and national all-academic honors."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Lab7 Reflection\n\n\n\n\n\nThe Advanced Encryption Standard\n\n\n\n\n\nNov 11, 2024\n\n\nDaniel Fajardo\n\n\n\n\n\n\n\n\n\n\n\n\nLab5 Reflection\n\n\n\n\n\nInterrupts\n\n\n\n\n\nOct 25, 2024\n\n\nDaniel Fajardo\n\n\n\n\n\n\n\n\n\n\n\n\nLab4 Reflection\n\n\n\n\n\nDigital Audio\n\n\n\n\n\nOct 21, 2024\n\n\nDaniel Fajardo\n\n\n\n\n\n\n\n\n\n\n\n\nLab3 Reflection\n\n\n\n\n\nKeypad Scanner\n\n\n\n\n\nSep 24, 2024\n\n\nDaniel Fajardo\n\n\n\n\n\n\n\n\n\n\n\n\nLab2 Reflection\n\n\n\n\n\nMultiplexed 7-Segment Display\n\n\n\n\n\nSep 15, 2024\n\n\nDaniel Fajardo\n\n\n\n\n\n\n\n\n\n\n\n\nLab1 Reflection\n\n\n\n\n\nFPGA and MCU Setup and Testing\n\n\n\n\n\nSep 7, 2024\n\n\nDaniel Fajardo\n\n\n\n\n\n\n\n\n\n\n\n\nHello Quarto\n\n\n\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 30, 2024\n\n\nDaniel Fajardo\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Introduction\nThis weeks lab was focused on setting up and testing the FPGA and MCU boards that will be used for the rest of the course. This lab involved soldering all the necessary components onto the e-155 protoboard, downloading the software interfaces: Lattice Radiant and SEGGER Embedded Studio, as well as the simulation software: ModelSim. Demo code was provided to verify that each software and hardware component was functioning correctly. Finally, the design part of the lab was to provide a 7 segment led digit display which corresponds to its binary input on the protoboard. This design was both simulated and verified with test vectors in ModelSim and was implemented with Lattice Radiant.\n\n\nDesign and Testing Methodology\n\n\n\nFigure 1: 7-segment key\n\n\nThe 7-segment display contains seven leds corresponding to their orientation in the digit. These segments are turned on by driving a pin in the fpga to 0V, so that the common anode in the display will produce a current through the appropriate led. To do this, a module for the combinational logic was implemented based on the key in Figure 1. In addition to the segment logic, three on board leds were driven (two were combinational from input and one blinked at 2.4 Hz). The blinking led was generated by the on-board high-speed oscillator from the iCE40UP library, which was divided by a clock divider module to match the desired frequency.\n\n\nTechnical Documentation\nThe source code for the project can be found in the associated Github Repository\n\n\nBlock Diagram\n\n\n\nFigure 2: Block diagram of the Verilog design\n\n\nThe block diagram in Figure 2 illustrates the architecture of the Verilog HDL. The top module contains a high speed oscillator (HSOSC), a counter, and two submodules: segment logic module, which contains combinational logic for the 7-segment output pins and a leds module, which contains combinational logic for the on board LEDs.\n\n\nSchematic\n\n\n\nFigure 3: Schematic of the physical circuit\n\n\nThe schematic, as illustrated by Figure 3, shows the circuit layout for both the internal FPGA operations and the external 7-segment display. The schematic shows the internal pullup resistors (100 kOhms each) and digital switches which drive the output pins to 0 or 3.3V, and the on-board switches for the input pins. The schematic also shows the 390 Ohm resistors connected to the 7-segment pins to avoid metastability.\n\n\nResults and Discussion\n\n\n\nFigure 4: Testbench simulation\n\n\nFigure 4 shows a simulation of a couple binary inputs to the system. The seg row shows the led segments in the 7-segment display as well as the additional leds that will be lit for each input (note that seg is inverted when compared to the key in Figure 1, because the segments are active low).\n\n\n\nFigure 5: Digit 0 being illuminated\n\n\nOverall, the lab was successful. The 7-segment display properly illuminated each of the 16 hexidecimal bits (Figure 5 illustrates the digit 0 being illuminated) and the on board leds followed the correct combinational logic and blinking frequency. The design was simulated in QuestaSim manually with various input bits and each time output the correct segment bits. One shortcoming of the lab was the lack of a testbench for QuestaSim, however with more time this would have been done. Additionally, the on-board led blinking frequency was only roughly 2.4 Hz, but could be achieved with a counter with more efficiency than only powers of 2.\n\n\nConclusion\nThe design successfully output each hexadecimal digit on the 7-segment display, and each led on the protoboard. Overall, 25 hours were spent working on this lab, although much of that time was spent soldering the board and testing the software."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab3: Keypad Scanner",
    "section": "",
    "text": "Introduction\nThis lab again expanded upon the previous two labs by adding a keypad scanner to the existing multiplexed 7-segment display. The keypad contains each hexadecimal digit and upon button press, the 7-segment displays will record the most recent two inputs. The keypad will only record one button push at a time and will hold the value of the first button pressed if multiple are pressed simultaneously.\n\n\nDesign and Testing Methodology\n\n\n\nFigure 1: Finite State Machine\n\n\nThis lab continued to build on the FPGA desing of the previous two labs. Again, this solution began with the clock divider module, as discussed in the previous labs, with a clk output of a little over 90 Hz. This clk was input into each submodule to synchronize them on the rising clock edge. Synchronous design allowed for the implementation of a finite state machine, as visualized in Figure 1. The first four states of the FSM cycle through, driving one column in the keypad at a time (the functionality of the keypad will be discussed further in the schematic section). While driving the columns, it will scan to see if any of the rows have been activated. If no rows have been detected, then it will cycle to the next column state, where a different column output is driven. In these first four states, if any rows have been detected, it will jump into one of the next four states (corresponding to column), and it will look for which row and column have been pressed in order to determine which button on the 4x4 keypad has been pressed and output the corresponding hexidecimal bit in binary. After one cycle, depending on which row has been pressed, the next four states hold until the row input is no longer detected, and when this happens it will cycle back to the start.\nThe FSM will have two outputs in each state, the 4-bit hexidecimal representation of the pressed button (hex) and the column output. The hex output should only be updated in the middle four states, so an additional enable is output as 1 in only these states. The first eight states will output only one bit in the 4-bit column output so that only one column is driven. In the hold states, all the columns are held high to avoid contention if multiple buttons in the same row have been pressed together.\nThe chosen finite state machine is simpler than alternative designs that were considered. Specifically, because there are 16 buttons that could be pressed, there could have been 16 states to register the button press and 16 hold states. The implemented design condensed these states, making the solution logic easier to digest.\nWhen the hex output is updated, it will move to the right most bit in the two digit display. To do this, the default displays will be zero, and when enabled, the most recent digit will be displayed on the left and the previous digit will move to the right. Once the two displays have been determined, they are input into the same multiplexed 7-segment display modules from the previous lab.\n\n\nTechnical Documentation\nThe source code for the project can be found in the associated Github Repository\n\n\nBlock Diagram\n\n\n\nFigure 2: Block diagram of verilog\n\n\nFigure 2 illustrates the block diagram of the overall design. The clockdivider module outputs a common clock to each other submodule in the design. The main FSM is held in the keypadinput module, which drives the column output and determines the hex representation of the button that was pressed. Hex is then sent to the hex module, which updates which two digits to display. Those two digits are then sent to the same chooseanode and segmentlogic modules from the previous labs.\n\n\nSchematic\n\n\n\nFigure 3: Schematic of physical circuit\n\n\n\n\n\nFigure 4: Schematic of keypad\n\n\nThe circuit schematic can be seen in Figure 3. The right side of the schematic is identical to the multiplexed 7-segment display design from the previous lab. The left side of the schematic shows both the column outputs and the row inputs (which have pulldown resistors rather than the onboard pullup resistors) to the keypad. The diagram of the schematic also shows which rows and columns are connected to each pin. Figure 4 shows the internal schematic of the keypad, which is composed of a 4x4 matrix of buttons. For this reason, the columns are cyclicly driven and the rows are scanned.\n\n\nResults and Discussion\n\n\n\nFigure 5: Keypadinput ModelSim testbench\n\n\nThis lab was successful in meeting all the lab requirements. Figure 5 shows a QuestaSim testbench simulation of the fsm logic module. As pictured, when a row input is detected, the column is held and the hex is recorded. It then stays in the hold state (note that column should be 1111 in the hold state) until the row input is no longer detected. Multiple row inputs has no effect on the state.\n\n\n\nFigure 6: Top Level ModelSim testbench\n\n\nFigure 6 shows the top level QuestSim testbench simulation. This testbench provides less detail, but demonstrates the design functioning as would be seen in hardware.\nThe design was also successful in hardware, with the circuit correctly detecting inputs and displaying the last two on the 7-segment displays. Only one button is registered at a time and a second input will not be registered until the first is released. The only shortcoming of the design was the potential for switch bouncing, a mechanical issue, where a switch makes and breaks its connection on a scale of microseconds. However, there was no sign of this being an issue. This could be because the clock runs at ~90 Hz, which might be slow enough for this to be a nonissue.\n\n\nConclusion\nThe design registered a button pressed on a 4x4 keypad and displayed the two most recent bits on two 7-segment displays. The design appears to have no issues. I spent a total of 30 hours working on this lab."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab5: Interrupts",
    "section": "",
    "text": "Introduction\nThis lab focused on using interrupts to measure the speed of a motor by measuring from a quadrature encoder. The MCU is able to calculate the speed and direction of the motor and prints to the output window in SEGGER at a rate of 1 Hz. The speed is determined by the number of interrupts during the sampling period and the direction is determined by the relative time between the pulses of the two sensors in the quadrature sensor.\n\n\nDesign and Testing Methodology\nThe External Interrupt/Event (EXTI) peripheral was configured by the MCU to detect pulses triggered from the two signals in the quadrature encoder. The pulses were configured for pins PA5 and PA10. These pins were chosen because interrupts triggered on these pins are handled by different interrupt request (irq) handlers, EXTI9_5_IRQn and EXTI15_10_IRQn respectively. To calculate velocity, each interrupt handler contains a counter for every time it is triggered. As the motor spins, each signal pulses 120 times per revolution, and the velocity is calculated by dividing this counter by a sample period. The two sensors are offset by a phase of 90 degrees, so the direction can be determined by the time between their interrupt trigger. The 12 V motor is capable of spinning up to 10 revolutions per second and with 120 pulses per revolution, the encoder needs to be able to register time at a frequency high enough to account for each pulse. For this reason, TIM6 was configured with a frequency of 10 MHz. This timer needed to be separate from the timer used in the main loop, so TIM2 was configured. For convenience, this timer was set to the same frequency, and a delay_micros function was written to set a delay for a given number of microseconds.\n\n\nTechnical Documentation\nThe source code for the project can be found in the associated Github Repository\n\n\nFlow Chart\n\n\n\nFigure 1: Flow Chart\n\n\nFigure 1 shows the flow chart of the solution. After initializing the GPIO pins, timers, interrupts, and global variables, the main function enters a permanent while loop, which first calculates the velocity and direction, then prints each in the output window in SEGGER. Then the loop is delayed by 1000000 microseconds (1 second) so that the calculations are updated at 1 Hz. The interrupts will be triggered at any point in the loop, but are illustrated where they are because the calculate functions are dependent on them.\n\n\nSchematic\n\n\n\nFigure 2: Schematic of physical circuit\n\n\nThe only analog interface is the motor and so the schematic is very straight forward, with the supply to the motor and the two sensors hooked up to the pins on the MCU.\n\n\nResults and Discussion\n\n\n\nFigure 3: Verification of results using a tachometer\n\n\nThe solution was able to correctly read the speed and dircetion of the motor of a quadrature encoder. The accuracy of the design was verified by comparing to the measurement of a non-contact tachometer (Figure 3). At 12 V, the motor should be spinning at 10 rev/s (based on datasheet) and the solution measured 10.08 rev/s, while the tachometer measured ~10.3 rev/s. At lower voltages, the tachometer continued to measure slightly higher speeds, suggesting that the tachometer was calibrated differently, but that the design scales correctly. The direction was verified by observation.\n\n\nConclusion\nThe design was able to measure the speed and direction of a motor and print the update this in the output window in SEGGER at a rate of 1 Hz. Interrupts were correctly utilizes to do so. This lab took about 10 hours to complete."
  },
  {
    "objectID": "posts/lab2-reflection.html",
    "href": "posts/lab2-reflection.html",
    "title": "Lab2 Reflection",
    "section": "",
    "text": "This lab went much smoother than the first lab, although not without its hiccups. My largest struggle in this lab was debugging the hardware. For the longest time I was having trouble getting both displays to appear on at the same time. I had thouhgt that I simply had incorrect clock logic (which was partially true), but the main issue turned out to be poor connections in the solder joints. This led to inconsistent outputs on the breadboard and a debugging nightmare. After getting the 7-segment displays to finally work, the adder had two leds which did not work because of floating points in the pinouts.\nThis lab again used the on-board high-speed oscillator (HSOSC), which seemed to be working. However, designing the clock module took a lot of debugging, and the issue turned out to be in the reset switch. The input I used for the switch was active high, which meant that it would be continuously resetting. This issue also caused some frustration.\nOne limitation I discovered on the protoboard was the lack of onboard switches. The previous lab used the four onboard switches, but this lab had to utilize standard I/O pins to access external switches. A similar problem was had with the onboard leds. The previous lab utilized three onboard leds but this lab requires five leds and so again the leds were accessed with standard I/O pins. These two design pivots seemed inconvenient, but they gave me a chance to better organize my breadboard circuitry.\nOverall, this lab was incredibly frustrating. I felt like I immediately grasped the correct conceptual understanding of the lab, but the implementation took much longer than expected. Still, I think these frustrations will ultimately help me grow as an engineer and teach me lessons in patience and perseverance."
  },
  {
    "objectID": "posts/lab4-reflection.html",
    "href": "posts/lab4-reflection.html",
    "title": "Lab4 Reflection",
    "section": "",
    "text": "This lab had a steep learning curve, similar to the first lab, with the majority of the time spent trying to understand the nuances of working with the STM32 MCU and reading its reference manual. I also found that this lab required the most guidance compared to the earlier labs. I found that, when I got stuck, the internet was not very helpful, and I often could not become unstuck until I talked it out with another person who had more knowledge than I did. This became frustrating, over fall break, when I did not have access to these resources. However, with this guidance, I feel like my understanding of the relevant concepts rapidly improved. Because of these road blocks, this lab took the most number of days to complete, but slightly less time than the average lab.\nThis lab is notorious for its susceptibility to typos and misinputs and I fell victim to it. The amount of times I would be missing just one line or even one bit caused so much headache. I spent so much time debugging the system, not understanding why it wasn’t working, only to realize that I had commented out the line that enables the main output.\nWith the completion of this lab, I feel like I have a significantly better understanding of the operations of a microcontroller at a low level and future projects feel much less intimidating. I am excited again to learn more after feeling demoralized and defeated because this lab was not working. This class has once again given me a chance to develop my perseverance."
  },
  {
    "objectID": "posts/lab7-reflection.html",
    "href": "posts/lab7-reflection.html",
    "title": "Lab7 Reflection",
    "section": "",
    "text": "This lab helped me develop efficient debugging techniques. This lab felt like a giant puzzle with many different pieces all needing to work to perform the overall function. Because of this, I needed to ensure that each piece was working how I expected it to, and to do this, I wrote testbenches for each submodule. This process was tedious but it helped reduce time spent debugging by giving more transparency to the text as it underwent encryption.\nThe most difficult part of this lab was dealing with sequential functions which took multiple clock cycles to finish. The keyexpansion module gave me the biggest challenge, as it not only took two cycles to complete, but it also was required to be finished before the other modules could be executed.\nThis lab has helped me develop my patience, as I often found myself not making much progress while debugging. It also gave me more practice with persevering through struggle."
  }
]