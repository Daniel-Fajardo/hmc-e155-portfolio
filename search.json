[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "E155 Course Website"
  },
  {
    "objectID": "posts/lab3-reflection.html",
    "href": "posts/lab3-reflection.html",
    "title": "Lab3 Reflection",
    "section": "",
    "text": "This lab was very intellectually challenging for me. The process of understanding how the fsm should function took some time and then figuring out how to approach it was more difficult. Once I had a solid grasp, I was able to get the design to work well in simulation in little time. The speed of development was thanks to implementing testbenches in QuestaSim for the first time in this class, which allowed for quick debugging.\nThe frustrating part of this lab came in trying to transfer a design that was working perfectly in simulation into a design that works in hardware. My first issue came in synthesizing the design in Lattice Radiant. I had inferred a number of latches by not defining each output in each state in my fsm. By splitting my fsm into multiple fsms in the same module (one for state, nextstate, and others for outputs), I solved this issue. The next issue came from the button push not registering correctly. In simulation, a button input would hold the column high, but this was not happening in hardware. I realized that the timing of the column output was not correct and that I was also getting contention when buttons in multiple rows were pushed at the same time. These issues remained for a while but once I discovered them, the fix was quick.\nAfter finally getting the design to work in hardware, I felt mostly relief. I felt relief because I had felt like I had total conceptual understanding of the problem, yet the system was not acting how I expected it to. This lab gave me practice in perseverance and patience. After about two weeks of working on this lab, I took a few days off, and on the first day back working on it I was able to figure it out."
  },
  {
    "objectID": "posts/lab1-reflection.html",
    "href": "posts/lab1-reflection.html",
    "title": "Lab1 Reflection",
    "section": "",
    "text": "The most difficult part of this lab by far was debugging each software application so that it would correctly upload to the fpga and mcu. The challenges lied in assuring that I had the correct software installed with the correct licenses and the correct hardware drivers. On my personal device, I struggled to get Lattice Radiant to synthesize the FPGA and getting SEGGER to drive the MCU remains unresolved. Because of these struggles, I had to complete the lab using the computers in HMCâ€™s digital lab.\nOnce the software and hardware appeared to be working enough to get started, I found the verilog module design to be fairly straight forward. Calculating the combinational logic for the 7-segment display was the most labor intensive part of the process for me and writing the HDL was quite simple. There was minimal debugging of the code, as the majority of the debugging came from understanding how Lattice Radiant works.\nThis lab also challenged my orginizational skills. This was the first project I have organized using github and learning the nuances took some time."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "Introduction\nThis lab expanded on the previous lab by adding a second 7-segment digit display to the FPGA design. Instead of adding FPGA I/O pins to the design, the two displays were accessed via a multiplexer which oscillated at a rate just fast enough to give the illusion of them both being on at the same time. This lab also implemented transistors to turn on/off each display.\n\n\nDesign and Testing Methodology\nThe System Verilog in this lab was much more modular than in the previous lab. This lab resused the clock divider and 7-segment logic modules. This time the clock divider was adjusted to output clk at a frequency just above 90 Hz (this is the frequency at which humans are able to register) so that the two displays would appear on at the same time. At each positive edge of the clock, the chooseanode module would alternate which display would receive current to its anode. The current to each display was controlled via a transistor. The chooseanode module would also operate a mux (separate module) to select which of the two 4-bit inputs would be active and the chosen input would be sent to the 7-segment logic module, which would output the corresponding digit display. Finally, a module called leds would act as a full adder for the two inputs and would output the 5-bit sum on external leds.\n\n\nTechnical Documentation\nThe source code for the project can be found in the associated Github Repository\n\n\nBlock Diagram\n\n\n\nFigure 1: Block diagram of verilog\n\n\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The clock divider module utilizes the on-board high speed oscillator (HSOSC) from the iCE40 library and outputs the clock to be used for the choose anode module. The other two submodules are the segment logic and the leds module.\n\n\nSchematic\n\n\n\nFigure 2: Schematic of physical circuit\n\n\n\n\n\nFigure 3: Pinout legend\n\n\nThe schematic in Figure 2 shows the layout of the circuitry. The FPGA board is shown on the left with internal pull up resistors for the inputs and outputs. The inputs include the on-board 4-pin dip switch and an external 4-pin dip switch. The outputs include the leds, which are current limited by resistors, the segment display signals, which are connected in parallel, and finally the transistors, which have the 3.3V connected to the collector pins and a resistor connected to the base, while the emitter is hooked up to the display anodes. Figure 3 illustrates the corresponding I/O pins in the schematic and block diagram.\n\n\nResults and Discussion\nThe design was mostly successful. In simulation, the selected anode would correclty alternate on the rising edge of the clock and the led adder logic also produced the expected outputs. The 7-segment logic continued to work, as it did in the previous lab. With all this, the top level module worked successfully, outputting the correct 7-segment and led logic at an alternating times. Given more time, I would like to create a testbench to more properly demonstrate the operation of the design.\nIn hardware, the design is fully successful only a fraction of the time. A large reason for this is poor solder joints which lead to incosistent pinouts. Another shortcoming is the current draw to some of the pins. This lab requires a large amount of current draw to handle all of its desired outputs. The 7-segment leds are not getting quite enough current and this is likely due to a large current pull elsewhere. I hope to adress each of these issues in the coming weeks, so that the design can perform more consistently, although when it does work it is reliably.\n\n\nConclusion\nThe design semiconsistently displays two digits using a mux to alternate between the displays at a frequency higher than the human eye can perceive. The design operates successfully at the will of the solder joint connections and with inconsistent current draw to each led. This lab took me roughly 20 hours to complete."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Daniel Fajardo is an engineering major at Harvey Mudd College. He is interested in pursuing a career in both electrical and mechanical engineering with a focus on areas that intersect both fields, such as mechatronics and systems engineering. His specific interests include embedded systems and microcontrollers, mechanical motion dynamics, and electrical design, which can be used to develop hardware and software solutions for automation and control systems. He also has a concentration in psychology and applies an interdisciplinary approach to solving engineering problems with environmental and human centered design considerations. He is also a member of the Claremont-Mudd-Scripps cross country team, receiving all-region awards and national all-academic honors."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Lab4 Reflection\n\n\n\n\n\nDigital Audio\n\n\n\n\n\nOct 4, 2024\n\n\nDaniel Fajardo\n\n\n\n\n\n\n\n\n\n\n\n\nLab3 Reflection\n\n\n\n\n\nKeypad Scanner\n\n\n\n\n\nSep 24, 2024\n\n\nDaniel Fajardo\n\n\n\n\n\n\n\n\n\n\n\n\nLab2 Reflection\n\n\n\n\n\nMultiplexed 7-Segment Display\n\n\n\n\n\nSep 15, 2024\n\n\nDaniel Fajardo\n\n\n\n\n\n\n\n\n\n\n\n\nLab1 Reflection\n\n\n\n\n\nFPGA and MCU Setup and Testing\n\n\n\n\n\nSep 7, 2024\n\n\nDaniel Fajardo\n\n\n\n\n\n\n\n\n\n\n\n\nHello Quarto\n\n\n\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 30, 2024\n\n\nDaniel Fajardo\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "Introduction\nThis weeks lab was focused on setting up and testing the FPGA and MCU boards that will be used for the rest of the course. This lab involved soldering all the necessary components onto the e-155 protoboard, downloading the software interfaces: Lattice Radiant and SEGGER Embedded Studio, as well as the simulation software: ModelSim. Demo code was provided to verify that each software and hardware component was functioning correctly. Finally, the design part of the lab was to provide a 7 segment led digit display which corresponds to its binary input on the protoboard. This design was both simulated and verified with test vectors in ModelSim and was implemented with Lattice Radiant.\n\n\nDesign and Testing Methodology\n\n\n\nFigure 1: 7-segment key\n\n\nThe 7-segment display contains seven leds corresponding to their orientation in the digit. These segments are turned on by driving a pin in the fpga to 0V, so that the common anode in the display will produce a current through the appropriate led. To do this, a module for the combinational logic was implemented based on the key in Figure 1. In addition to the segment logic, three on board leds were driven (two were combinational from input and one blinked at 2.4 Hz). The blinking led was generated by the on-board high-speed oscillator from the iCE40UP library, which was divided by a clock divider module to match the desired frequency.\n\n\nTechnical Documentation\nThe source code for the project can be found in the associated Github Repository\n\n\nBlock Diagram\n\n\n\nFigure 2: Block diagram of the Verilog design\n\n\nThe block diagram in Figure 2 illustrates the architecture of the Verilog HDL. The top module contains a high speed oscillator (HSOSC), a counter, and two submodules: segment logic module, which contains combinational logic for the 7-segment output pins and a leds module, which contains combinational logic for the on board LEDs.\n\n\nSchematic\n \nThe schematic, as illustrated by Figure 3, shows the circuit layout for both the internal FPGA operations and the external 7-segment display. The schematic shows the internal pullup resistors (100 kOhms each) and digital switches which drive the output pins to 0 or 3.3V, and the on-board switches for the input pins. The legend for all the pinouts is listed in Figure 4. The schematic also shows the 390 Ohm resistors connected to the 7-segment pins to avoid metastability.\n\n\nResults and Discussion\n\n\n\nFigure 5: Digit 0 being illuminated\n\n\nOverall, the lab was successful. The 7-segment display properly illuminated each of the 16 hexidecimal bits (Figure 5 illustrates the digit 0 being illuminated) and the on board leds followed the correct combinational logic and blinking frequency. The design was simulated in QuestaSim manually with various input bits and each time output the correct segment bits. One shortcoming of the lab was the lack of a testbench for QuestaSim, however with more time this would have been done. Additionally, the on-board led blinking frequency was only roughly 2.4 Hz, but could be achieved with a counter with more efficiency than only powers of 2.\n\n\nConclusion\nThe design successfully output each hexadecimal digit on the 7-segment display, and each led on the protoboard. Overall, 25 hours were spent working on this lab, although much of that time was spent soldering the board and testing the software."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab3: Keypad Scanner",
    "section": "",
    "text": "Introduction\nThis lab again expanded upon the previous two labs by adding a keypad scanner to the existing multiplexed 7-segment display. The keypad contains each hexadecimal digit and upon button press, the 7-segment displays will record the most recent two inputs. The keypad will only record one button push at a time and will hold the value of the first button pressed if multiple are pressed simultaneously.\n\n\nDesign and Testing Methodology\n\n\n\nFigure 1: Finite State Machine\n\n\nThis lab continued to build on the FPGA desing of the previous two labs. Again, this solution began with the clock divider module, as discussed in the previous labs, with a clk output of a little over 90 Hz. This clk was input into each submodule to synchronize them on the rising clock edge. Synchronous design allowed for the implementation of a finite state machine, as visualized in Figure 1. The first four states of the FSM cycle through, driving one column in the keypad at a time (the functionality of the keypad will be discussed further in the schematic section). While driving the columns, it will scan to see if any of the rows have been activated. If no rows have been detected, then it will cycle to the next column state, where a different column output is driven. In these first four states, if any rows have been detected, it will jump into one of the next four states (corresponding to column), and it will look for which row and column have been pressed in order to determine which button on the 4x4 keypad has been pressed and output the corresponding hexidecimal bit in binary. After one cycle, depending on which row has been pressed, the next four states hold until the row input is no longer detected, and when this happens it will cycle back to the start.\nThe FSM will have two outputs in each state, the 4-bit hexidecimal representation of the pressed button (hex) and the column output. The hex output should only be updated in the middle four states, so an additional enable is output as 1 in only these states. The first eight states will output only one bit in the 4-bit column output so that only one column is driven. In the hold states, all the columns are held high to avoid contention if multiple buttons in the same row have been pressed together.\nThe chosen finite state machine is simpler than alternative designs that were considered. Specifically, because there are 16 buttons that could be pressed, there could have been 16 states to register the button press and 16 hold states. The implemented design condensed these states, making the solution logic easier to digest.\nWhen the hex output is updated, it will move to the right most bit in the two digit display. To do this, the default displays will be zero, and when enabled, the most recent digit will be displayed on the left and the previous digit will move to the right. Once the two displays have been determined, they are input into the same multiplexed 7-segment display modules from the previous lab.\n\n\nTechnical Documentation\nThe source code for the project can be found in the associated Github Repository\n\n\nBlock Diagram\n\n\n\nFigure 2: Block diagram of verilog\n\n\nFigure 2 illustrates the block diagram of the overall design. The clockdivider module outputs a common clock to each other submodule in the design. The main FSM is held in the keypadinput module, which drives the column output and determines the hex representation of the button that was pressed. Hex is then sent to the hex module, which updates which two digits to display. Those two digits are then sent to the same chooseanode and segmentlogic modules from the previous labs.\n\n\nSchematic\n\n\n\nFigure 3: Schematic of physical circuit\n\n\n\n\n\nFigure 4: Schematic of keypad\n\n\n\n\n\nFigure 5: Pinout legend\n\n\nThe circuit schematic can be seen in Figure 3. The right side of the schematic is identical to the multiplexed 7-segment display design from the previous lab. The left side of the schematic shows both the column outputs and the row inputs (which have pulldown resistors rather than the onboard pullup resistors) to the keypad. The diagram of the schematic also shows which rows and columns are connected to each pin. Figure 4 shows the internal schematic of the keypad, which is composed of a 4x4 matrix of buttons. For this reason, the columns are cyclicly driven and the rows are scanned. The pinouts for the FPGA are also illustrated in Figure 5.\n\n\nResults and Discussion\n\n\n\nFigure 6: Keypadinput ModelSim testbench\n\n\nThis lab was successful in meeting all the lab requirements. Figure 6 shows a QuestaSim testbench simulation of the fsm logic module. As pictured, when a row input is detected, the column is held and the hex is recorded. It then stays in the hold state (note that column should be 1111 in the hold state) until the row input is no longer detected. Multiple row inputs has no effect on the state.\n\n\n\nFigure 7: Top Level ModelSim testbench\n\n\nFigure 7 shows the top level QuestSim testbench simulation. This testbench provides less detail, but demonstrates the design functioning as would be seen in hardware.\nThe design was also successful in hardware, with the circuit correctly detecting inputs and displaying the last two on the 7-segment displays. Only one button is registered at a time and a second input will not be registered until the first is released. The only shortcoming of the design was the potential for switch bouncing, a mechanical issue, where a switch makes and breaks its connection on a scale of microseconds. However, there was no sign of this being an issue. This could be because the clock runs at ~90 Hz, which might be slow enough for this to be a nonissue.\n\n\nConclusion\nThe design registered a button pressed on a 4x4 keypad and displayed the two most recent bits on two 7-segment displays. The design appears to have no issues. I spent a total of 30 hours working on this lab."
  },
  {
    "objectID": "posts/lab2-reflection.html",
    "href": "posts/lab2-reflection.html",
    "title": "Lab2 Reflection",
    "section": "",
    "text": "This lab went much smoother than the first lab, although not without its hiccups. My largest struggle in this lab was debugging the hardware. For the longest time I was having trouble getting both displays to appear on at the same time. I had thouhgt that I simply had incorrect clock logic (which was partially true), but the main issue turned out to be poor connections in the solder joints. This led to inconsistent outputs on the breadboard and a debugging nightmare. After getting the 7-segment displays to finally work, the adder had two leds which did not work because of floating points in the pinouts.\nThis lab again used the on-board high-speed oscillator (HSOSC), which seemed to be working. However, designing the clock module took a lot of debugging, and the issue turned out to be in the reset switch. The input I used for the switch was active high, which meant that it would be continuously resetting. This issue also caused some frustration.\nOne limitation I discovered on the protoboard was the lack of onboard switches. The previous lab used the four onboard switches, but this lab had to utilize standard I/O pins to access external switches. A similar problem was had with the onboard leds. The previous lab utilized three onboard leds but this lab requires five leds and so again the leds were accessed with standard I/O pins. These two design pivots seemed inconvenient, but they gave me a chance to better organize my breadboard circuitry.\nOverall, this lab was incredibly frustrating. I felt like I immediately grasped the correct conceptual understanding of the lab, but the implementation took much longer than expected. Still, I think these frustrations will ultimately help me grow as an engineer and teach me lessons in patience and perseverance."
  },
  {
    "objectID": "posts/lab4-reflection.html",
    "href": "posts/lab4-reflection.html",
    "title": "Lab4 Reflection",
    "section": "",
    "text": "I have not yet been able to spend much time on this lab. This is a placeholder."
  }
]